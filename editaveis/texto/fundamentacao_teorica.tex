\chapter{Basic Concepts}
\label {sec:basic_concepts}

This chapter gives an overview on some basic concepts needed by the reader to understand this work. It starts talking about games and game design, then talks a little about the Linux Filesystem, that helps developers to understand where their binaries and other files should go on the user's system. At the end, there are brief words on repositories and packages.

\section{Games}
\label {sec:games}

Games have been a part of human development since their early childhood and have been part of history in its most basic ways \cite{bethke2003game}. The basic assumption of a game is that it provides a fun time, bonding and usually learning of new skills. Even though there are many games meant to play alone, they normally are meant to play with someone else (even if that someone is the computer), because the interaction with something is a key concept for any game.

They can take several format, like board, card, dice games. Each format has unique strategies to win. Board games usually divide the user space in sectors, and everything is related to which sectors you are in and how you control them. Card games are related to symbols (the cards) and the possible combinations of them \cite{crawford1984art}.

Since computers were invented they completely changed the gaming world. New kind of games, like \textit{first person shooter} and \textit{tower defense}, were created and made popular. With the Internet, it became even easier to own and play different games, also it's possible to play almost any game with anyone in the world.

Because computer games are software with audio, art and gameplay, they should follow a software development method, any one chosen by the team. This is something that most game developers avoid \cite{bethke2003game}, because they see their work as pure art. Although that is certainly true, a game has everything a \lq\lq normal software\rq\rq{} has and more. Using software engineering techniques (adapted to their needs, naturally) will result on a better game and better interaction with the final user \cite{pressman2009software}

\section{Game Platforms}
\label {sec:game_platforms}


\section{SDL}
\label {sec:sdl}

Simple DirectMedia Layer (SDL) is a library that helps developers by creating cross-platform APIs in order to make easier handling video, input, audio, threads. It's used in several games available in big platforms like \textit{Steam} and \textit{Humble Bundle} \cite{sdl2017}. In order to be fully integrated with the developer's code, a few files are needed during the compilation: the headers, that contains definitions of functions and structures; and the library itself, that contains the binaries that will run with the main code, and may be static and shared \cite{lazyfoo2017}.

A shared library is one that can be used in multiple programs. It provides common code that is reusable and can be linked to the developer's code at running time. On Linux systems they have the \textit{.so} file extension, while on Windows they have \textit{.dll} \cite{howto2017shared}. In this case, the library code is not merged to the main code, resulting in a smaller binary for the developer. It's required to have the library installed in the user's system, though.

The static library is compiled against the main source code and it's merged to it. Instead of being a dependency on the user's system, it's now a part of the distributed version of the software, resulting in a bigger binary.


\section{Filesystem Hierarchy Standard}
\label {sec:fhs}

The Filesystem Hierarchy Standard was proposed on February 14, 1994 as an effort to rebuild the file and directory structure of Linux and, later, all Unix-like systems. It helps developers and users to predict the location of existing and new files on the system, by proposing how minimum files, directories and guiding principles \cite{allbery2015filesystem}.

The Hierarchy starts defining types of files that can exist in a system. Whenever files differ in this classification, they should be located in different parts of the system: \textit{shareable} files are the ones that can be accessed from a remote host, while \textit{unshareable} are files that have to be on the same machine to be obtained. \textit{Static} files are the ones that aren't supposed to be changed without administrator privileges, whereas \textit{variable} ones can be changed by regular users \cite{allbery2015filesystem}

The root filesystem is defined then: this should be as small as possible and it should contain all the required files to boot, reset or repair the system. It must have the directories specified on Table \ref{tab:directories} and installed software should never create new directories on this filesystem \cite{allbery2015filesystem}.


\begin{table}[h!]
\centering
\caption{Directories on the Hierarchy \cite{allbery2015filesystem}}
\label{tab:directories}
\rowcolors{2}{gray!30}{white}
\begin{tabular}{ll}
\toprule
\textbf{Directory} & \textbf{Description} \\
\midrule
\texttt{bin} & Essential command binaries \\
\texttt{boot} & Static files of the boot loader \\
\texttt{dev} & Device files \\
\texttt{etc} & Host-specific system configuration \\
\texttt{lib} & Essential shared libraries and kernel modules \\
\texttt{media} & Mount point for removable media \\
\texttt{mnt} & Mount point for mounting a filesystem temporarily \\
\texttt{opt} & Add-on application software packages \\
\texttt{run} & Data relevant to running processes \\
\texttt{sbin} & Essential system binaries \\
\texttt{srv} & Data for services provided by this system \\
\texttt{tmp} & Temporary files \\
\texttt{usr} & Secondary hierarchy \\
\texttt{var} & Variable data \\
\bottomrule
\end{tabular}
\end{table}


From the directories in Table \ref{tab:directories}, \lq\lq \texttt{/usr}, \texttt{/opt} and \texttt{/var} are designed such that they may be located on other partitions or filesystems.\rq\rq{} \cite[p. 3]{allbery2015filesystem}. The \texttt{/usr} hierarchy should include shareable data, that means that every information host-specific should be placed in other directories.

About the \texttt{/var} hierarchy, FHS specifies that \lq\lq everything that once went into \texttt{/usr} that is written to during system operation (as opposed to installation and software maintenance) must be in \texttt{/var}.\rq\rq{}  \cite[p. 30]{allbery2015filesystem}.


\section{Repository}
\label {sec:repository}

According to the Merriam-Webster Dictionary (\citeyear{webster2017repository}), a repository is \lq\lq a place, room or container where something is deposited.\rq\rq{} A software repository is a computer, directory or server that stores all the source code for that software project. This is usually available on the Internet, but it can also be local to the developers.

Repositories are also related to the version control of the source code being produced. The definition of version control is \lq\lq a system that records changes to a file or set of files over time so that you can recall specific versions later\rq\rq{} \cite{chacon2014pro}. This allows the user to compare versions, to check updates, see who introduced (or removed) an issue and to rollback to previous versions of the system \cite{chacon2014pro}. The goal is to make it easy to return to states that were working, even after changes are made after a long time.

Modern version control systems allow developers to work on a distributed basis and to parallel their tasks, with the ability of \textit{branching} the repository. Those \textit{branches} are separated lines of development, that won't mess with the main one until they are merged \cite{chacon2014pro}. This feature lets developers create and test new changes before submitting them to the project stable line of work, without affecting the final product.

\section{Packages}
\label {sec:packages}

In computer science package can have multiple meanings, depending on the context being used. A Linux package means a bundle of files containing the required data to run an application, such as binaries and information about the package.

Most Linux distributions have their own package managers. Each expects and handle different types of files, but all of them have the common goal of making the installation easier. They download the package, resolve dependencies, copy the needed binaries and execute any post- or pre-configuration required by the system to install a package \cite{linode2017linux}. For example, Debian has \textit{dpkg}, Red Hat has \textit{rpm} and Arch Linux has \textit{pacman} as default package managers.

Another installing method is compiling from scratch. This may be very handy if the user is more advanced or the package is not in the package manager's repository. However, in this case, the user will have to manually handle dependencies, download, compile and do everything else the manager does.

\subsection{CMake}
\label {sec:cmake}

Creating packages for multiple platforms requires a lot of time and effort, because it has to be compiled on each of the systems, with those system's libraries, binaries and architecture. In order to make this task easier, several cross-platform building tools were created.

CMake was created to fulfill the need for \lq\lq a powerful, cross-platform build environment for the Insight Segmentation and Registration Toolkit\rq\rq{} \cite{cmake2017overview}. It is \lq\lq a system that manages the build process in an operating system and in a compiler-independent manner\rq\rq{} \cite{cmake2017overview}.

In a very clever way, CMake generates native compiling and configuration scripts (like makefiles for Unix and namespaces for Windows) and use them to build the package \cite{cmake2017overview}. It is also designed to be used with the native environment, unlike other building tools \cite{cmake2017overview}.

The building process is controlled by files named \texttt{CMakeLists.txt}. They can have commands to generate a building environment, set needed variables, compile dependencies, link required libraries and install the project. A project that has many subdirectories, each with their own rules, can have multiple \texttt{CMakeLists.txt} to create the final product.
